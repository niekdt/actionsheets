import os.path
import shutil
from pathlib import Path
from typing import TextIO

import polars as pl
from actionsheets.sheet import ActionsheetView
from actionsheets.sheets import Actionsheets, default_sheets


def generate_all_sheets(path: str) -> None:
    sheets = default_sheets()
    generate_sheets(sheets, parent_id='', path=path)


def generate_sheets(sheets: Actionsheets, parent_id: str, path: str) -> None:
    for sheet_id in sheets.sheets(parent=parent_id, nested=False):
        info = sheets.sheet_info(sheet_id)
        sheet_dir_path = os.path.join(path, info['sheet_name'])
        shutil.rmtree(sheet_dir_path, ignore_errors=True)
        Path(sheet_dir_path).mkdir(exist_ok=True)

        generate_sheet(
            view=sheets.sheet_view(sheet_id),
            path=os.path.join(sheet_dir_path, 'index.md')
        )
        generate_sheets(
            sheets=sheets,
            parent_id=sheet_id,
            path=sheet_dir_path
        )


def generate_sheet(view: ActionsheetView, path: str) -> None:
    with open(path, mode='w', encoding='utf-8') as file:
        _write_sheet_header(info=view.info, file=file)
        _write_sections(view=view, file=file, section='')


def _write_sheet_header(info: dict, file: TextIO) -> None:
    tags_block = ''.join(['  - ' + tag + '\n' for tag in info['keywords']])
    date_line = '' if info['date'] is None else f"date: {info['date']}"
    file.write(f"""---
title: {info['title']}
{date_line}
tags:
{tags_block}
---\n""")

    file.write('<!-- This file was autogenerated by Actionsheets. Do not modify! -->\n\n')

    if info['partial']:
        file.write('''<div data-search-exclude markdown>
??? warning "Incomplete sheet"

    This sheet is incomplete and could use some attention. Please submit code snippet suggestions as an issue or PR [here](https://github.com/niekdt/actionsheets/issues).
</div>\n\n''')

    file.write(f"# {info['title']}\n{info['description']}\n\n")

    if info['details']:
        file.write(f"**Details**\n{info['details']}\n\n")

    if info['code']:
        file.write(f"**Code**\n```{info['language']}\n{info['code']}\n```\n\n")


def _write_sections(view: ActionsheetView, file: TextIO, section: str) -> None:
    for section_id in view.entries(type='section', parent=section, nested=False):
        _write_section(view, file=file, section=section_id)


def _write_section(view: ActionsheetView, file: TextIO, section: str):
    info = view.section_info(section=section)

    depth = section.count('.')
    h = 2 + depth if depth < 6 else 6

    file.write('{pounds} {title}\n'.format(pounds='#' * h, title=info['title']))
    if info['description']:
        file.write(info['description'] + '\n')

    _write_section_snippets(view, file=file, section=section)

    # Render subsections
    _write_sections(view, file=file, section=section)


def _write_section_snippets(view: ActionsheetView, file: TextIO, section: str) -> None:
    data = view.section_snippets(section=section)
    if data.height:
        return _write_snippets(data, file=file)


def _write_snippets(data: pl.DataFrame, file: TextIO) -> None:
    assert data.height > 0

    file.write('''<table markdown = "1">
<thead>
<tr>
<th class="th-action">Action</th>
<th class="th-code">Code</th>
<th class="th-details">Details</th>
</tr>
</thead>\n''')

    html_data = data.with_columns(
        action=pl.concat_str(
            pl.lit('<td markdown="1">\n'), pl.col('title'), pl.lit('\n</td>\n')
        ),
        code=pl.concat_str(
            pl.lit('<td>\n```'),
            pl.col('language'),
            pl.lit('\n'),
            pl.col('code'),
            pl.lit('\n```\n</td>\n')
        ),
        details=pl.concat_str(
            pl.lit('<td markdown="1">'), pl.col('details'), pl.lit('</td>\n')
        )
    ).with_columns(
        line=pl.concat_str(
            pl.lit('<tr markdown="1">\n'),
            pl.col('action'),
            pl.col('code'),
            pl.col('details'),
            pl.lit('</tr>\n')
        )
    )

    file.writelines(html_data['line'].to_list())
    file.write('</table>\n')


def _indent(x: str):
    lines = x.splitlines()
    indented_lines = ['\t' + line for line in lines]
    return '\n'.join(indented_lines)
