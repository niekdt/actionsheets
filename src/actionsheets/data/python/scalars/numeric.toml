language = "python"
parent = "python.scalars"
name = "numeric"
title = "Numeric"

[constants]
section = "Constants"

[constants.'nan']
action = "NaN"
code = "math.nan"

[constants.'nan'.float]
code = "float('nan')"

[constants.'nan'.numpy]
code = "numpy.nan"

[constants.'inf']
action = "Infinity"
code = "math.inf"

[constants.'inf'.float]
code = "float('inf')"

[constants.'inf'.numpy]
code = "numpy.inf"

[constants.ninf]
action = "Negative infinity"
code = "-math.inf"

[constants.ninf.float]
code = "float('-inf')"

[constants.ninf.numpy]
code = "numpy.NINF"

[constants.pi]
action = "Pi"
code = "math.pi"

[constants.e]
action = "e"
code = "math.e"

[constants.int.min]
action = "Min int"
code = "-sys.maxsize"

[constants.int.max]
action = "Max int"
code = "sys.maxsize"

[constants.float.eps]
action = "Float epsilon (smallest representable difference)"
code = "sys.float_info.epsilon"

[constants.float.min]
action = "Min float"
code = "sys.float_info.min"

[constants.float.max]
action = "Max float"
code = "sys.float_info.max"


[create]
section = "Create"
description = "int() and float() throw ValueError if the input cannot be parsed"

[create.int.binary]
action = "Binary integer"
code = "[sign]0b[b2int]"
details = "-0b10 (-2)"

[create.int.hex]
action = "Hex integer"
code = "[sign]0x[b16int]"
details = "e.g., -0xF (-16)"

[create.int.str]
action = "Integer from string"
code = "int(x)"

[create.int.str.hex]
action = "Integer from hex string (base 16)"
code = "int(x, 16)"
details = "e.g., DEADBEEF"

[create.int.str.prefix]
action = "Integer from string with base determined by prefix"
code = "int(x, 0)"
details = "Base 10 by default, base-16 for 0x, base-2 for 0b"

[create.int.str.locale]
action = "Integer from string according to locale"
code = "locale.atoi(x)"

[create.uint.bytes]
action = "Unsigned integer from bytes"
code = "int.from_bytes(x, byteorder='big')"

[create.int.bytes]
action = "Signed integer from bytes"
code = "int.from_bytes(x, byteorder='big', signed=True)"

[create.float.str]
action = "Float from string"
code = "float(x)"
details = "Throws ValueError if string cannot be parsed"

[create.float.bytes]
action = "Float from packed struct bytes"
code = "struct.unpack('f', x)[0] | e.g., b'x00x00 @'"

[create.float.str.hex]
action = "Float from hex string representation"
code = "float.fromhex(x)"

[create.float.str.locale]
action = "Float from string for locale"
code = "locale.atof(x)"

[create.float.str.locale.tmp]
action = "Float from string for temporary locale"
code = "Babel.parse_decimal('1,25', locale='nl_NL.utf8')"
details = "No way to do this cleanly and thread-safe in standard Python..."

[create.float.str.locale.tmp.2]
code = """
loc = locale.getlocale(locale.LC_NUMERIC)
locale.setlocale(locale.LC_NUMERIC, 'nl_NL')
f = locale.atof(x)
locale.setlocale(locale.LC_NUMERIC, loc)
"""

[test]
section = "Test"

[test.int]
action = "Integer"
code = "type(x) is int"

[test.number.whole]
action = "Whole number"
code = "float.is_integer(x)"
details = "e.g., True for 5.0"

[test.equal.approx.prop]
action = "Approximately equal"
code = "math.isclose(x, y)"
details = "Uses proportional tolerance"

[test.equal.approx.tol]
action = "Approximately equal with absolute tolerance _tol_"
code = "math.isclose(x, y, abs_tol=tol)"

[test.equal.approx.prop.tol]
action = "Approximately equal with proportional tolerance _tol_%"
code = "math.isclose(x, y, rel_tol=tol)"

[test.'nan']
action = "NaN"
code = "math.isnan(x)"
details = "Does not work for complex numbers (?)"

[test.finite]
action = "Finite"
code= "math.isfinite(x)"

[test.'inf']
action = "Infinite"
code = "math.isinf(x)"

[test.pinf]
action = "Positive infinity"
code = "math.isinf(x) and x > 0"

[test.ninf]
action = "Negative infinity"
code = "math.isinf(x) and x < 0"


[extract]
section = "Extract"

[extact.bits]
action = "Number of bits needed to represent the integer (ignoring sign)"
code = "x.bit_length()"
details = "Same as `floor(log2(|x|))`"


[convert]
section = "Convert"

[convert.str]
action = "String"
code = "str(x)"

[convert.float.str.locale]
action = "Float to string according to locale"
code = "locale.str(float)"

[convert.hash]
action = "Hash"
code = "hash(x)"

[convert.int.bytes]
action = "Int to bytes"
code = "x.to_bytes(8, byteorder='big')"
details = "`OverflowError` is raised if the integer is not representable with the given number of bytes"

[convert.int.bytes.signed]
code = "x.to_bytes(8, byteorder='big', signed=True)"

[convert.int.bytes.array]
action = "Count to byte array (mutable)"
code = "bytearray(x)"

[convert.float.bytes]
action = "Float to bytes"
code = "struct.pack('f', x)"

[convert.int.str.hex]
action = "Int to hex string"
code = "hex(x)"
details = "Format: `[sign] ['0x'] integer"

[convert.float.str.hex]
action = "Float to hex string representation"
code = "x.hex()"
details = "Format: `[sign] ['0x'] integer ['.' fraction] ['p' exponent]`, e.g., `0x1.400000p+1`"
